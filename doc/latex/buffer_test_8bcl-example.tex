\hypertarget{buffer_test_8bcl-example}{\section{buffer\+\_\+test.\+bcl}
}
A fielded buffers, that contain attribute-\/value pairs called fields.

The attribute is the field’s identifier, and the associated value represents the field’s data content. Fielded buffers provide an excellent structure for communicating parameterized data between cooperating processes, by providing named access to a set of related fields. Programs that need to communicate with other processes can use the F\+M\+L software to provide access to fields withou concerning themselves with the structures containing them.

\begin{DoxyAuthor}{Author}
herbert koelman(\href{mailto:herbert.koelman@me.com}{\tt herbert.\+koelman@me.\+com})
\end{DoxyAuthor}

\begin{DoxyCodeInclude}
1 /* $Id$
2 
3    Sample Tuxedo client using ATMI++ libray.
4 
5  */
6 #include <stdlib.h>
7 #include <unistd.h>
8 #include <string.h>
9 #include <string>
10 #include <iostream>
11 #include <fstream>
12 #include <typeinfo>
13 #include "atmi/atmi++.hpp"
14 
15 #include "sample\_fml\_table.h"
16 
17 
18 class buffer\_test : public atmi::abstract\_client \{
19   public:
20     buffer\_test (): class\_field\_empname("EMPNAME"), atmi::abstract\_client ("btest")\{
21     \};
22 
23     int run ( int argc, char **argv )\{
24       try \{
25 
26         atmi::buffer b (100), a;
27         /*
28            const char *types[5] = \{ typeid(short).name(), typeid(int).name() \};
29            std::cout << "Stored: " << types[0] << std::endl;
30            std::cout << "Stored: " << types[1] << " is a " << std::endl;
31            if(strcmp ( typeid(int).name(), types[1]) == 0 )\{
32            std::cout << "same type int." << std::endl;
33            \}
34            std::cout << "Type id " << typeid(long).name() << std::endl;
35          */
36 
37         std::cout << "atmi::buffer b: " << b.used() << "/" << b.unused() <<", size: " << b.size() << ",
       chksum: " << b.chksum() <<  std::endl;
38 
39         class\_field\_empname = "Hello" ;
40         std::cout << "class\_field\_empname (" << class\_field\_empname.what() << "): " << class\_field\_empname
       << std::endl;
41 
42         try \{
43 
44           atmi::Tfield<std::string> prenom ( "EMPNAMEE" );
45 
46         \}catch ( std::exception &err )\{
47           std::cerr << "field name error: " << err.what() << std::endl ;
48         \}
49 
50         try \{
51 
52           atmi::Tfield<long> prenom ( EMPNAME );
53 
54         \}catch ( std::exception &err )\{
55           std::cerr << "field type error: " << err.what() << std::endl ;
56         \}
57 
58         atmi::Tfield<std::string> prenom ( EMPNAME );
59         atmi::Tfield<long>   empid ( EMPID );
60         atmi::Tfield<long>   empzip ( EMPZIP );
61         atmi::Tfield<std::string> nom ( EMPNAME );
62         atmi::Tfield<char *> carray ( SRVCDAY );
63         atmi::Tfield<char *> copy ( SRVCDAY );
64 
65         prenom = "herbert";
66         nom = "this is a char *";
67         empid = 2;
68         carray.set\_char\_array("hello world\(\backslash\)0rray", 16);
69 
70         std::cout << "--------------------------------------" << std::endl << std::endl ;
71         std::cout << "Direct carray buffer access" << std::endl ;
72         // const char *direct\_access = carray ;
73         // auto direct\_access\_length = carray.length();
74 
75         for ( auto x = 0; x < carray.length() ; x++ )\{
76           // printf("%c - %c\(\backslash\)n", direct\_access[x], carray[x]);
77           printf("%c\(\backslash\)n", carray[x]);
78         \}
79         printf("\(\backslash\)n");
80         carray[1] = 'X' ;
81         printf("changed character 1 to X -> %c\(\backslash\)n", carray[1]);
82 
83         std::cout << "--------------------------------------" << std::endl << std::endl ;
84         std::cout << "copy carrays" << std::endl;
85         copy = carray;
86 
87         std::cout << "--------------------------------------" << std::endl << std::endl ;
88         std::cout << "Adding fields into FML buffer: " << std::endl;
89         b.add ( empid );
90         b.add ( nom );
91         b.add ( prenom );
92         b.set ( carray );
93         b.print ();
94         std::cout << "--------------------------------------" << std::endl << std::endl ;
95 
96         std::cout << "get SRVCDAY value from FML buffer" << std::endl;
97         b.get ( copy );
98         std::cout << "there should be enough memory no re-allocation expected" << std::endl;
99         b.get ( copy );
100 
101         std::cout << "--------------------------------------" << std::endl << std::endl ;
102 
103         copy.set\_char\_array("0123456789", 10);
104         std::cout << "buffer carray contains " << copy.length() << " characters" << std::endl ;
105         //b.remove(copy);
106         b.set(copy);
107         b.print();
108 
109         atmi::Tfield<char *> resize\_control ( SRVCDAY );
110         std::cout << "resize control initial carray length is  " << resize\_control.length() << std::endl;
111         resize\_control.set\_char\_array("012345678901245678900123456789", 30);
112         b.get(resize\_control);
113 
114         std::cout << "de-allocate ressources" << std::endl ;
115         resize\_control.free\_ressources();
116         std::cout << "  firt call to get from buffer, size before call " << resize\_control.length() <<
       std::endl ;
117         b.get(resize\_control);
118         std::cout << "  second call to get from buffer, size before second call " <<
       resize\_control.length() << std::endl ;
119         b.get(resize\_control);
120         std::cout << "size is " << resize\_control.length() << ", backend store size is " <<
       resize\_control.buffer\_size() << std::endl ;
121 
122         std::cout << "--------------------------------------" << std::endl << std::endl ;
123         std::cout << copy.what() << std::endl;
124         long len = 5;                  //copy.length();
125         char *cav = new char[len];
126         copy.get\_char\_array ( cav, len );
127         for ( int x = 0; x < len; x++ ) \{
128           std::cout << "'"<< cav[x]<<"',";
129         \}
130         std::cout << std::endl;
131 
132         std::cout << "Setting (update) empid value: " << std::endl;
133         empid = 22;
134         b.set ( empid );
135         b.print ();
136 
137         std::cout << "size : " << b.size();
138         b.pack ();
139         std::cout << ", after pack: " << b.size() << std::endl;
140 
141         std::cout << "atmi::buffer (in the end): " << b.used() << "/" << b.unused() <<", size: " <<
       b.size() << ", chksum: " << b.chksum() <<  std::endl;
142 
143         std::cout << "wrapping atmi::buffer." << std::endl ;
144         atmi::buffer wrapper ( b.get\_buffer());
145         nom = "this was added into a wrapper instance of atmi::buffer.";
146         wrapper.set (nom );
147         wrapper.print ();
148 
149         std::cout << "transforming a atmi::buffer into a wrapped buffer." << std::endl;
150         atmi::buffer wrapper1;
151         wrapper1.set\_buffer ( wrapper.get\_buffer());
152         prenom = "this was set by a wrapper";
153         wrapper1.set ( prenom );
154         wrapper1.print();
155 
156       \}catch ( atmi::buffer\_exception &err ) \{
157         std::cerr << err.what() << ". Ferror : " << err.error() <<std::endl;
158       \} catch ( atmi::atmi\_exception &err ) \{
159         std::cerr << err.what() << std::endl;
160       \} catch ( std::exception &err ) \{
161         std::cerr << err.what() << std::endl;
162       \}
163 
164       return 9999;
165     \}
166 
167   private:
168     atmi::Tfield<std::string> class\_field\_empname;
169 
170 \};
171 
172 // program main -------------------------------------------------
173 
174 int main ( int argc, char **argv ) \{
175 
176   try \{
177 
178     std::cout << "atmi::buffer sample program (" << atmi::cpp\_atmi\_version() <<")." << std::endl;
179     buffer\_test btest;
180 
181     std::cout << ", starting up" ;
182     btest.run ( argc, argv );
183 
184   \} catch ( atmi::atmi\_exception &err)\{
185     std::cerr << std::endl << err.what() << std::endl;
186   \} catch ( std::exception &err ) \{
187     std::cerr << std::endl << err.what() << std::endl;
188   \}
189   std::cout << ", done." << std::endl;
190 
191   return 0;
192 \}
\end{DoxyCodeInclude}
 