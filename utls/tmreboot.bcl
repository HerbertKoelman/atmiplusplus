/*
 * tmreboot is a tuxedo client that restart server using MIB calls
 *
 * environment
 * FLDTBLDIR=$TUXDIR/udataobj
 * FIELDTBLS=tpadm,evt_mib
 *
 * Return codes EXIT_SUCCESS or EXIT_FAULED
 */

#include <cstdio>
#include <cstring>
#include <unistd.h>
#include <sys/types.h>
#include <atmi/atmi++.hpp>
#include "options.hpp" // basename, class options
#include <tpadm.h>
#include <evt_mib.h>
#include <userlog.h>

enum server_state {
  ACTIVE,
  INACTIVE
};

/** search servers entries and stop/start them.
 *
 * @since v4.6.0
 */
class domain: public atmi::abstract_client {
  public:

    /** connect to Tuxedo domain and setup class.
     *
     * this client uses a privileged user which avoids authentication.
     *
     * @param pname program name
     */
    domain(const char *pname): 
      abstract_client("tpsysadm", "tpsysadm", (char *) "syspass", (char *) "apppass", (char *) NULL, (char *) NULL ),
      _program_name(pname),
      _counter(0),
      _dry_run(false)
    {
      // intentional
    }

    /** reboot function
     *
     * @param server_name server name
     * @param server_id server ID
     * @param group server group
     * @param sequence boot sequence
     * @return number servers successfully restarted.
     */
    void reboot(const char *server_name, const int server_id, const char *group, const int sequence){

      try {
        if ( ! _dry_run ){
          userlog ((char *) "tmreboot criterions:  server %s, group %s, srvid %d, sequence %d", server_name, group, server_id, sequence);
        }

        atmi::buffer entries(Fneeded32(6, 1024)); 

        atmi::transaction_ptr MIB = new_transaction_instance(".TMIB"); // MIB service

        atmi::Tfield<std::string> ta_operation(TA_OPERATION);
        atmi::Tfield<std::string> ta_class(TA_CLASS);
        atmi::Tfield<long>        ta_flags(TA_FLAGS);
        atmi::Tfield<std::string> ta_state(TA_STATE);

        atmi::Tfield<std::string> ta_servername(TA_SERVERNAME);
        atmi::Tfield<long>        ta_srvid(TA_SRVID);
        atmi::Tfield<long>        ta_sequence(TA_SEQUENCE);
        atmi::Tfield<std::string> ta_srvgrp(TA_SRVGRP);

        atmi::Tfield<long>        ta_more(TA_MORE);
        atmi::Tfield<long>        ta_occurences(TA_OCCURS);

        ta_class = "T_SERVER" ;
        ta_state = "ACT";
        ta_flags = MIB_LOCAL ; // this let the MIB query return the statistics of each server found (set 0 if not required)
        ta_operation = "GET"; // first call -> GET, next calls -> GETNEXT

        entries.set(ta_flags);
        entries.set(ta_class);
        entries.set(ta_state);
        entries.set(ta_operation);

        if ( server_name != NULL ){ ta_servername = server_name ; entries.set(ta_servername);}
        if ( server_id   != 0 )   { ta_srvid = server_id ; entries.set(ta_srvid);}
        if ( sequence    != 0 )   { ta_sequence = sequence ; entries.set(ta_sequence);}
        if ( group       != NULL ){ ta_srvgrp = group ; entries.set(ta_srvgrp);}

        do{
          // serahc for server entires.
          MIB->call(entries);

          entries.get(ta_more);
          if ( ta_more > 0 ) {
            ta_operation = "GETNEXT" ;
            entries.set(ta_operation);
          }

          entries.get(ta_occurences);

          for ( long occurence = ta_occurences - 1 ; occurence >= 0 ; occurence--){
            entries.get(ta_servername, occurence);
            entries.get(ta_srvid, occurence);
            entries.get(ta_srvgrp, occurence);
            //entries.print();

            if ( ta_srvid == 0 ){
              std::cerr << "cannot restart BBL" << std::endl;
            } else {
              if ( _dry_run ){
                _counter++ ; // increment the number of restarted server
                printf ("DRY RUN would have restarted server %s (srvid: %d, group: %s)\n", basename((char *)ta_servername.c_str()), (long) ta_srvid, ta_srvgrp.c_str());
              } else {
                printf ("restarting server %s (srvid: %d, group: %s)\n", basename((char *)ta_servername.c_str()), (long) ta_srvid, ta_srvgrp.c_str());
                stop (ta_srvid, ta_srvgrp);
                start(ta_srvid, ta_srvgrp);
                _counter++ ; // increment the number of restarted server
              }
            }
          }
        } while( ta_more > 0 ) ;

        // entries.print();

      } catch ( std::exception &err ){
        std::cerr << "reboot failed: " << err.what() << std::endl;
      }
    }

    /** changes state of given server to ACTIVE
     *
     * @param server_id server ID
     * @param group server's group name
     */
    void stop( int server_id, const std::string &group){

      change_server_state("INACTIVE", server_id, group) ;
    }

    /** changes state of given server to INACTIVE
     *
     * @param server_id server ID
     * @param group server's group name
     */
    void start( int server_id, const std::string &group){

      change_server_state("ACTIVE", server_id, group) ;
    }

    void change_server_state( const std::string &state, int server_id, const std::string &group){

      atmi::buffer query; 
      atmi::Tfield<std::string> ta_status(TA_STATUS);

      try{
        // userlog((char *) "stopping server %d in group %s", server_id, group.c_str() );

        atmi::transaction_ptr MIB = new_transaction_instance(".TMIB"); // MIB service

        atmi::Tfield<std::string> ta_operation(TA_OPERATION);
        atmi::Tfield<std::string> ta_class(TA_CLASS);
        atmi::Tfield<std::string> ta_state(TA_STATE);
        atmi::Tfield<long>        ta_error(TA_ERROR);

        atmi::Tfield<long>        ta_srvid(TA_SRVID);
        atmi::Tfield<std::string> ta_srvgrp(TA_SRVGRP);

        ta_srvid     = server_id;
        ta_srvgrp    = group ;
        ta_operation = "SET";
        ta_class     = "T_SERVER" ;
        ta_state     = state ;

        query.set(ta_srvid);
        query.set(ta_srvgrp);
        query.set(ta_operation);
        query.set(ta_state);
        query.set(ta_class);

        MIB->call(query);

        //query.print();

      } catch ( std::exception &err ){
        query.get(ta_status);
        throw atmi::atmi_exception("failed to change server state to %s. %s, %s", state.c_str(), err.what(), ta_status.c_str());
      }
    }

    /** set dry run flag.
     *
     * if true then no action is taken and actions are displayed on stdout.
     *
     * @param flag dry run flag value
     */
    void set_dry_run( bool flag ){
      _dry_run = flag;
    }

    /** @return dry run flag current value.
     */
    bool get_dry_run() const {
      return _dry_run ;
    }

    long counter() const {
      return _counter ; 
    }
  private:
    bool        _dry_run ;
    long        _counter ;
    std::string _program_name;
};

void print_usage( char *pname ) {

    fprintf(stdout, "usage : %s [-n] -g grpname | -i srvid | -s srvname -o seqno\n\n", pname);
    fprintf(stdout, "restart server processes.\n");
    fprintf(stdout, "-g group name\n");
    fprintf(stdout, "-i server ID\n");
    fprintf(stdout, "-s server name\n");
    fprintf(stdout, "-o sequence number\n");
    fprintf(stdout, "-n dry run, displays what would have been restarted.\n");
    fprintf(stdout, "-N restart only if the number requests done is greater then this value\n");
}

int main(int argc, char *argv[]) {

  auto status = EXIT_FAILURE;

  char  *group = NULL;
  char  *srvname = NULL; 
  long   srvid = 0;
  long   seqid = 0;

  char  *pname = basename(argv[0]); // get program name

  long  nbd = 0;
  int   opt;
  int arguments = 0; // number of arguments found
  bool  err = false;

  /* used by getopt line parser */
  extern char *optarg;
  extern int   optind;
  extern int   opterr;   

  opt = '\0';

  try {
    // connect client
    domain admin(pname);

    while ((opt = getopt(argc, argv, "g:i:o:s:N:n")) != -1) { // NOSONAR usual implementation
      switch(opt) {
        case 'g':
          group = optarg;
          arguments++;
          break;
        case 'i':
          srvid = atoi (optarg);
          break;
        case 'o':
          seqid = atoi (optarg);
          arguments++;
          break;
        case 's':
          srvname = optarg;
          arguments++;
          break;
        case 'N':
          nbd = atoi (optarg);
          if (nbd < 1) {
            fprintf (stdout, " N lower than 1 is not relevant\n");
          } else {
            fprintf (stdout, ">> only servers at least called %d times\n", nbd);
          }
          break;
        case 'n':
          admin.set_dry_run(true);
          break;
        default :
          fprintf (stderr, "Unknown option ... EXITING \n");
          err=true;
      } /* end switch */
    }

    if ( arguments > 0 ){
      admin.reboot(srvname, srvid, group, seqid);
      std::cout << admin.counter() << " processes restarted." << std::endl;
      status = EXIT_SUCCESS;
    } else {
      std::cerr << "missing argument." << std::endl << std::endl ;
      print_usage(pname);
    }

  } catch ( std::exception &err ){
    std::cerr << err.what() << std::endl ;
  }

  exit(status);
}
