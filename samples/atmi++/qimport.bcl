#include <unistd.h>
#include <libgen.h>
#include <string.h>
#include <iostream>
#include "atmi.h"
#include <atmi++.h>

using namespace std;
using namespace atmi;

void usage ( char *pname ) {
  cout << "usage : " << pname << " -Q <qspace:queue>" << endl;
  cout << "enqueue the content of stdin into the given qspace:queue (messages are separated by a line feed (\\n))." << endl;
}

class QImport : AbstractClient {
public:
	QImport (): AbstractClient("qimport") {};

int run ( int argc, char **argv ) {

  int c = 0, status = -1;
  long size = 1024;
  char *qspace = NULL;
  char *queue  = NULL;

  if ( argc > 1 ) {

    while ( (c = getopt ( argc, argv, "s:Q:")) != -1 ) {

      switch ( c ) {

        case 's':
          size = atol ( optarg);
          break;

        case 'Q':
          qspace =  strtok ( optarg, ":");
          queue  = strtok (NULL, ":");
          cerr << "importing queue: <" << queue << "> from qspace: " << qspace << endl;
          break;

        case '?':
        default:
          usage ( basename (argv[0]) );
          exit (status);
      }                           //end-switch
    } //end-while

    try {

      Queue q ( qspace, queue);

      cerr << "buffer size is " << size << endl;
      QueueStream qs ( &q, size );
      cin >> qs;

      cerr << "handled " << qs.getCount() << " messages. import done." << endl;

    } catch ( DiagnosticException diagErr ) {
      cerr << "import failed." << diagErr.what() << endl;
    } catch ( TuxedoException tuxErr ) {
      cerr << "import failed." << tuxErr.what() << endl;
    }

  } else {
    usage ( basename (argv[0]));
  }

  return status;
}
};

int main ( int argc, char **argv ) {

	int rc = 0 ;

  try {

		cout << "Using ATMI++ version: " << Tuxedo::version() << endl ;
		QImport qi ;
		rc = qi.run ( argc, argv );

	} catch ( Exception err ) {
		cerr << err.what() << endl ;
	} catch ( exception uerr ) {
		cerr << uerr.what() << endl ;
	};

	return rc ;
}
