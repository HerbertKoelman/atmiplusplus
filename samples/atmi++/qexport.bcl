#include <limits.h>
#include <unistd.h>
#include <libgen.h>
#include <string.h>
#include <iostream>
#include <atmi++.h>

using namespace std;
using namespace atmi;


void usage ( char *pname ) {
  cerr << "usage : " << pname << " -Q <qspace:queue> [-w] [-s]" << endl;
  cerr << "send the content of the given qspace:queue to stdout (each message is separeted by a line feed (\\n)." << endl;
  cerr << " -Q qspace:queue - qspace and queue to read messages from (mandatory) " << endl;
  cerr << " -w indicates that we are willing to wait for a message to be posted (default is not to wait). " << endl;
  cerr << " -s buffer size in bytes. " << endl;
}

class QExport : public AbstractClient {
public:

  QExport () : AbstractClient () {
  };

  int run ( int argc, char **argv ) {

    int c = 0, status = -1;
    long size = 1024;
    char *qspace = NULL;
    char *queue  = NULL;

    if ( argc > 1 ) {

      try {

        Queue q;
        q.setQWait ( false );

        while ( (c = getopt ( argc, argv, "Q:ws:")) != -1 ) {

          switch ( c ) {

            case 's':
              size = atol ( optarg );
              break;

            case 'Q':
              qspace =  strtok ( optarg, ":");
              queue  = strtok (NULL, ":");

              q.set_queue_space ( qspace );
              q.set_queue ( queue );

              cerr << "exporting messages from queue: " << queue << " in qspace: " << qspace << ". ";
              break;

            case 'w':
              q.setQWait (true);
              cerr << " Running in wait mode.";
              break;

            case '?':
            default:
              usage ( basename (argv[0]) );
              exit (status);
          }                                       //end-switch

        }                         //end-while

        cerr << endl;

        cerr << "buffer size is " << size << "." << endl;
        QueueStream qs ( &q, size );
        cout << qs;
        cerr << "handled " << qs.getCount () << " messages. export done." << endl;

      } catch (DiagnosticException diagErr ) {
        cerr << "Export failed. " << diagErr.what() << endl;
      } catch (Exception tuxErr ) {
        cerr << "Export failed. " << tuxErr.what() << endl;
      }

    } else {
      usage ( basename (argv[0]));
    }

    return status;
  }

};

int main (int argc, char **argv ) {
  int status = 0;

  try {

		cout << "Using ATMI++ version: " << Tuxedo::version() << endl ;
    QExport qe;
    status = qe.run ( argc, argv );

  } catch ( Exception err ) {
    cerr << err.what() << endl;
  } catch ( exception uerr ) {
    cerr << uerr.what() << endl;
  };

  return status;
};
